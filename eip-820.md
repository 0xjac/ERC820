## Preamble

    EIP: 820
    Title: Pseudo-introspection using a registry contract.
    Author: Jordi Baylina @jbaylina
    Type: StandardTrack
    Category: ERC
    Status: Draft
    Created: 2018-01-05


## Simple Summary
This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it implements and which smart contract is responsible for its implementation.

## Abstract
This standard attempts to define a registry where smart contracts and regular accounts can publish which functionalities they implement.

The rest of the world can query this registry to ask if a specific address implements a given interface and which smart contract handles its implementation.

This registry can be deployed on any chain and will share the exact same address.

## Motivation

There has been different approaches to define pseudo-introspection in the Ethereum. The first is EIP-165 which has the problem that it is not available for regular accounts to use. The second approach is EIP-672 which uses reverseENS. Using reverseENS, has two issues. First, it is unnecessarily complex, and second, ENS is still a centralized contract controlled by a multisig.  This multisig, theoretically would be able to modify the system.

This standard is much simpler than EIP672 and it is absolutely decentralized.

This standard also solves the problem of having different addresses for different chains.

## Specification

### The smart contract

```
pragma solidity 0.4.19;

contract EIP820ImplementerInterface {
    function canManage(address addr, bytes32 interfaceHash) public returns(bool);
}

contract EIP820Registry {

    mapping (address => mapping(bytes32 => address)) interfaces;
    mapping (address => address) managers;

    modifier canManage(address addr) {
        require(getManager(addr) == msg.sender);
        _;
    }

    /// @notice Query the hash of an interface given a name
    /// @param interfaceName Name of the interfce
    function interfaceHash(string interfaceName) public pure returns(bytes32) {
        return keccak256(interfaceName);
    }

    /// @notice GetManager
    function getManager(address addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[addr] == 0) {
            return addr;
        } else {
            return managers[addr];
        }
    }

    /// @notice Sets an external `manager` that will be able to call `setInterfaceImplementer()`
    ///  on behalf of the address.
    /// @param addr Address that you are defining the manager for.
    /// @param newManager The address of the manager for the `addr` that will replace
    ///  the old one.  Set to 0x0 if you want to remove the manager.
    function setManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager == addr ? 0 : newManager;
        ManagerChanged(addr, newManager);
    }

    /// @notice Query if an address implements an interface and thru which contract
    /// @param addr Address that is being queried for the implementation of an interface
    /// @param iHash SHA3 of the name of the interface as a string
    ///  Example `web3.utils.sha3('Ierc777`')`
    /// @return The address of the contract that implements a speficic interface
    ///  or 0x0 if `addr` does not implement this interface
    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address) {
        return interfaces[addr][iHash];
    }

    /// @notice Sets the contract that will handle a specific interface; only
    ///  the address itself or a `manager` defined for that address can set it
    /// @param addr Address that you want to define the interface for
    /// @param iHash SHA3 of the name of the interface as a string
    ///  For example `web3.utils.sha3('Ierc777')` for the Ierc777
    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr)  {
        if (implementer != 0) {
            require(EIP820ImplementerInterface(implementer).canManage(addr, iHash));
        }
        interfaces[addr][iHash] = implementer;
        InterfaceImplementerSet(addr, iHash, implementer);
    }

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    event ManagerChanged(address indexed addr, address indexed newManager);
}
```

### Raw transaction for deploying the smart contract on any chain.
```
0xf904fb8085174876e800830c35008080b904a86060604052341561000f57600080fd5b61048a8061001e6000396000f30060606040526004361061006c5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166329965a1d81146100715780633d5840631461009c5780635df8122f146100d757806365ba36c1146100fc578063aabbb8ca1461015f575b600080fd5b341561007c57600080fd5b61009a600160a060020a036004358116906024359060443516610181565b005b34156100a757600080fd5b6100bb600160a060020a03600435166102cc565b604051600160a060020a03909116815260200160405180910390f35b34156100e257600080fd5b61009a600160a060020a0360043581169060243516610318565b341561010757600080fd5b61014d60046024813581810190830135806020601f820181900481020160405190810160405281815292919060208401838380828437509496506103d395505050505050565b60405190815260200160405180910390f35b341561016a57600080fd5b6100bb600160a060020a0360043516602435610438565b8233600160a060020a0316610195826102cc565b600160a060020a0316146101a857600080fd5b600160a060020a038216156102535781600160a060020a031663fa1205d885856000604051602001526040517c010000000000000000000000000000000000000000000000000000000063ffffffff8516028152600160a060020a0390921660048301526024820152604401602060405180830381600087803b151561022d57600080fd5b6102c65a03f1151561023e57600080fd5b50505060405180519050151561025357600080fd5b600160a060020a0384811660008181526020818152604080832088845290915290819020805473ffffffffffffffffffffffffffffffffffffffff191693861693841790558591907f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db153905160405180910390a450505050565b600160a060020a0380821660009081526001602052604081205490911615156102f6575080610313565b50600160a060020a03808216600090815260016020526040902054165b919050565b8133600160a060020a031661032c826102cc565b600160a060020a03161461033f57600080fd5b82600160a060020a031682600160a060020a03161461035e5781610361565b60005b600160a060020a0384811660008181526001602052604090819020805473ffffffffffffffffffffffffffffffffffffffff191694841694909417909355908416917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a4350905160405180910390a3505050565b6000816040518082805190602001908083835b602083106104055780518252601f1990920191602091820191016103e6565b6001836020036101000a038019825116818451161790925250505091909101925060409150505180910390209050919050565b600160a060020a03918216600090815260208181526040808320938352929052205416905600a165627a7a7230582020e46e57cf9fae3dd546b017d03475dd891e6b30a7b3b9c1455e4363690a276600291ba079be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798a00aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

You can see the string `a` at the end. This is the `s` of the signature, meaning that its a deterministic by hand forced signature.

### Special registry deployment account.

```
0x123045bb07b4b3ff3113573132e75da4afc876d5
```

This account is generated by reverse engineering it from it's signature for the transaction, in this way no one knows the private key, but it is known that it's the valid signer of the deployment transaction.

### Deployment method.

The way to deploy this contract is by sending ETH to the registry deployment account and then broadcast the transaction.


### Deployed contract.
```
0x33592f752b4275b9e8289839bf650a4c5d23f960
```

The contract will have this address for every chain it is deployed to.


### Interface name
Your interface name is hashed and sent to getInterfaceImplementer(). If you are writing a standard, it is best practice to explicitly state the interface name and link to this published EIP 820 so that other people don't have to come here to look up these rules.

#### If it's an approved EIP
The interface is named like `erc20-XXXXX`. The meaning of this interface is defined in the EIP specified. And XXX should be the name of the interface camelCase.

Examples:

`erc20-Token`
`erc777-Token`
`erc777-TokenHolder`

#### Private user defined interface
This scheme is extensible. If you want to make up your own interface name and raise awareness to get other people to implement it and then check for those implementations, great! Have fun, but please do not conflict with the reserved designations above.

## Backwards Compatibility

This standard is not incompatible with EIP165, as both methods can be implemented without conflicting one each other.

## Test Cases

Please, check the repository https://github.com/jbaylina/eip820 for the full test suit.

## Implementation

The implementation can be found in this repo: https://github.com/jbaylina/eip820

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
